from flask import Flask, request, jsonify
import json
import base64
from datetime import datetime, timezone

app = Flask(__name__)

# API Key for authentication
API_KEY = "cvebuster-demo-key-12345"

def parse_iso_datetime(dt_str):
    """Parse ISO 8601 datetime string to datetime object."""
    try:
        # Handle both with and without 'Z' suffix
        if dt_str.endswith('Z'):
            dt_str = dt_str[:-1] + '+00:00'
        return datetime.fromisoformat(dt_str)
    except Exception as e:
        print(f"Error parsing datetime '{dt_str}': {e}")
        return None

def filter_by_time_range(vulnerabilities, start_time_str=None, end_time_str=None):
    """Filter vulnerabilities by LastModified time range."""
    if not start_time_str and not end_time_str:
        return vulnerabilities
    
    start_time = parse_iso_datetime(start_time_str) if start_time_str else None
    end_time = parse_iso_datetime(end_time_str) if end_time_str else None
    
    filtered = []
    for vuln in vulnerabilities:
        last_modified = parse_iso_datetime(vuln.get('LastModified', ''))
        if last_modified is None:
            continue
        
        # Check if within time range
        if start_time and last_modified <= start_time:
            continue
        if end_time and last_modified >= end_time:
            continue
        
        filtered.append(vuln)
    
    return filtered

@app.route('/api/vulnerabilities', methods=['GET'])
def get_vulnerabilities():
    """
    Get vulnerabilities with pagination support.
    Supports both 'next_token' and 'nextToken' parameter names.
    Supports time filtering via createdAt__gt and createdAt__lt parameters.
    """
    # Debug: Print incoming request details
    print("=" * 50)
    print("INCOMING REQUEST DEBUG")
    print("=" * 50)
    print(f"Method: {request.method}")
    print(f"URL: {request.url}")
    print(f"Path: {request.path}")
    print("\nHeaders:")
    for header, value in request.headers:
        print(f"  {header}: {value}")
    print("\nQuery Parameters:")
    for key, value in request.args.items():
        print(f"  {key}: {value}")
    print("=" * 50)
    
    # Check API key - handle both Basic auth and direct API key
    auth_header = request.headers.get('Authorization', '')
    print(f"DEBUG - Expected API Key: {API_KEY}")
    print(f"DEBUG - Received Authorization: '{auth_header}'")
    
    # Decode Basic auth if present
    api_key_to_check = None
    if auth_header.startswith('Basic '):
        try:
            # Decode base64: "Basic YXBpa2V5OmN2ZWJ1c3Rlci1kZW1vLWtleS0xMjM0NQ==" 
            # becomes "apikey:cvebuster-demo-key-12345"
            decoded = base64.b64decode(auth_header[6:]).decode('utf-8')
            print(f"DEBUG - Decoded Basic auth: '{decoded}'")
            # Split on ':' and take the password part (the API key)
            if ':' in decoded:
                username, api_key_to_check = decoded.split(':', 1)
            else:
                api_key_to_check = decoded
        except Exception as e:
            print(f"DEBUG - Failed to decode Basic auth: {e}")
            return jsonify({"error": "Unauthorized"}), 401
    else:
        # Direct API key (no Basic prefix)
        api_key_to_check = auth_header
    
    print(f"DEBUG - Extracted API Key: '{api_key_to_check}'")
    print(f"DEBUG - Match: {api_key_to_check == API_KEY}")
    
    if api_key_to_check != API_KEY:
        return jsonify({"error": "Unauthorized"}), 401
    
    # Load vulnerability data
    try:
        with open('cvebuster_data.json', 'r') as f:
            all_vulnerabilities = json.load(f)
    except FileNotFoundError:
        return jsonify({"error": "Data file not found"}), 500
    
    # Get time filter parameters (SentinelOne pattern)
    start_time = request.args.get('createdAt__gt')
    end_time = request.args.get('createdAt__lt')
    
    # Filter by time range if provided
    filtered_vulnerabilities = filter_by_time_range(all_vulnerabilities, start_time, end_time)
    
    # Get pagination parameters
    page_size = int(request.args.get('page_size', 50))
    next_token_param = request.args.get('next_token') or request.args.get('nextToken')
    
    # Decode offset from next_token (base64 encoded)
    if next_token_param:
        try:
            offset = int(base64.b64decode(next_token_param).decode('utf-8'))
        except:
            offset = 0
    else:
        offset = 0
    
    # Get paginated results
    start_idx = offset
    end_idx = offset + page_size
    page_vulnerabilities = filtered_vulnerabilities[start_idx:end_idx]
    
    # Calculate next token
    has_more = end_idx < len(filtered_vulnerabilities)
    next_token = base64.b64encode(str(end_idx).encode('utf-8')).decode('utf-8') if has_more else None
    
    # Log pagination details
    print(f"TimeFilter: {start_time} to {end_time}")
    print(f"Offset: {offset}, Filtered Records: {len(filtered_vulnerabilities)}, Returned: {len(page_vulnerabilities)}, Has Next: {has_more}")
    
    # Return response
    response = {
        "vulnerabilities": page_vulnerabilities,
        "next_token": next_token,
        "total_filtered": len(filtered_vulnerabilities),
        "page_size": page_size,
        "offset": offset
    }
    
    return jsonify(response)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
