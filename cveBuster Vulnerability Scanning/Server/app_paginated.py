from flask import Flask, request, jsonify
import json
import base64
from datetime import datetime, timezone

app = Flask(__name__)

# API Key for authentication
API_KEY = "cvebuster-demo-key-12345"

def parse_iso_datetime(dt_str):
    """Parse ISO 8601 datetime string to datetime object."""
    try:
        # Handle both with and without 'Z' suffix
        if dt_str.endswith('Z'):
            dt_str = dt_str[:-1] + '+00:00'
        return datetime.fromisoformat(dt_str)
    except Exception as e:
        print(f"Error parsing datetime '{dt_str}': {e}")
        return None

def filter_by_time_range(vulnerabilities, start_time_str=None, end_time_str=None):
    """Filter vulnerabilities by LastModified time range."""
    if not start_time_str and not end_time_str:
        return vulnerabilities
    
    start_time = parse_iso_datetime(start_time_str) if start_time_str else None
    end_time = parse_iso_datetime(end_time_str) if end_time_str else None
    
    filtered = []
    for vuln in vulnerabilities:
        last_modified = parse_iso_datetime(vuln.get('LastModified', ''))
        if last_modified is None:
            continue
        
        # Check if within time range
        if start_time and last_modified <= start_time:
            continue
        if end_time and last_modified >= end_time:
            continue
        
        filtered.append(vuln)
    
    return filtered

@app.route('/api/vulnerabilities', methods=['GET'])
def get_vulnerabilities():
    """
    Get vulnerabilities with pagination support.
    Supports both 'next_token' and 'nextToken' parameter names.
    Supports time filtering via createdAt__gt and createdAt__lt parameters.
    """
    # Debug: Print incoming request details
    print("=" * 50)
    print("INCOMING REQUEST DEBUG")
    print("=" * 50)
    print(f"Method: {request.method}")
    print(f"URL: {request.url}")
    print(f"Path: {request.path}")
    print("\nHeaders:")
    for header, value in request.headers:
        print(f"  {header}: {value}")
    print("\nQuery Parameters:")
    for key, value in request.args.items():
        print(f"  {key}: {value}")
    print("=" * 50)
    
    # Check API key - handle both Basic auth and direct API key
    auth_header = request.headers.get('Authorization', '')
    print(f"DEBUG - Expected API Key: {API_KEY}")
    print(f"DEBUG - Received Authorization: '{auth_header}'")
    
    # Decode Basic auth if present
    api_key_to_check = None
    if auth_header.startswith('Basic '):
        try:
            # Decode base64: "Basic YXBpa2V5OmN2ZWJ1c3Rlci1kZW1vLWtleS0xMjM0NQ==" 
            # becomes "apikey:cvebuster-demo-key-12345"
            decoded = base64.b64decode(auth_header[6:]).decode('utf-8')
            print(f"DEBUG - Decoded Basic auth: '{decoded}'")
            # Split on ':' and take the password part (the API key)
            if ':' in decoded:
                username, api_key_to_check = decoded.split(':', 1)
            else:
                api_key_to_check = decoded
        except Exception as e:
            print(f"DEBUG - Failed to decode Basic auth: {e}")
            return jsonify({"error": "Unauthorized"}), 401
    else:
        # Direct API key (no Basic prefix)
        api_key_to_check = auth_header
    
    print(f"DEBUG - Extracted API Key: '{api_key_to_check}'")
    print(f"DEBUG - Match: {api_key_to_check == API_KEY}")
    
    if api_key_to_check != API_KEY:
        return jsonify({"error": "Unauthorized"}), 401
    
    # Load vulnerability data
    try:
        with open('cvebuster_data.json', 'r') as f:
            all_vulnerabilities = json.load(f)
    except FileNotFoundError:
        return jsonify({"error": "Data file not found"}), 500
    
    # Get time filter parameters (SentinelOne pattern)
    start_time = request.args.get('createdAt__gt')
    end_time = request.args.get('createdAt__lt')
    
    # Filter by time range if provided
    filtered_vulnerabilities = filter_by_time_range(all_vulnerabilities, start_time, end_time)
    
    # Get pagination parameters
    page_size = int(request.args.get('page_size', 50))
    next_token_param = request.args.get('next_token') or request.args.get('nextToken')
    
    # Decode offset from next_token (base64 encoded)
    if next_token_param:
        try:
            offset = int(base64.b64decode(next_token_param).decode('utf-8'))
        except:
            offset = 0
    else:
        offset = 0
    
    # Get paginated results
    start_idx = offset
    end_idx = offset + page_size
    page_vulnerabilities = filtered_vulnerabilities[start_idx:end_idx]
    
    # Calculate next token
    has_more = end_idx < len(filtered_vulnerabilities)
    next_token = base64.b64encode(str(end_idx).encode('utf-8')).decode('utf-8') if has_more else None
    
    # Log pagination details
    print(f"TimeFilter: {start_time} to {end_time}")
    print(f"Offset: {offset}, Filtered Records: {len(filtered_vulnerabilities)}, Returned: {len(page_vulnerabilities)}, Has Next: {has_more}")
    
    # Return response
    response = {
        "vulnerabilities": page_vulnerabilities,
        "next_token": next_token,
        "total_filtered": len(filtered_vulnerabilities),
        "page_size": page_size,
        "offset": offset
    }
    
    return jsonify(response)

@app.route('/api/bobvm', methods=['GET'])
def get_bobvm_summary():
    """
    Get a formatted summary of BobVM's vulnerabilities for Defender comments.
    Returns a clean, actionable report on the 5 CVEs affecting BobVM.
    """
    try:
        with open('cvebuster_data.json', 'r') as f:
            all_vulnerabilities = json.load(f)
    except FileNotFoundError:
        return jsonify({"error": "Data file not found"}), 500
    
    # Filter for BobVM vulnerabilities
    bobvm_vulns = [v for v in all_vulnerabilities if v.get('MachineName') == 'BobVM']
    
    if not bobvm_vulns:
        return jsonify({"error": "No vulnerabilities found for BobVM"}), 404
    
    # Sort by CVSS score (highest first)
    bobvm_vulns.sort(key=lambda x: x.get('CVSS', 0), reverse=True)
    
    # Build formatted response
    report_lines = [
        "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—",
        "â•‘              BOBVM VULNERABILITY ASSESSMENT REPORT                   â•‘",
        "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•",
        "",
        f"ðŸ“Š Total Vulnerabilities: {len(bobvm_vulns)}",
        f"ðŸŽ¯ Asset Criticality: High",
        f"ðŸ“… Last Assessed: {datetime.now(timezone.utc).strftime('%Y-%m-%d %H:%M UTC')}",
        "",
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
        ""
    ]
    
    for idx, vuln in enumerate(bobvm_vulns, 1):
        # Determine severity emoji
        severity_map = {
            "Critical": "ðŸ”´",
            "High": "ðŸŸ ",
            "Medium": "ðŸŸ¡",
            "Low": "ðŸŸ¢"
        }
        severity_icon = severity_map.get(vuln.get('Severity', 'Medium'), "âšª")
        
        # Exploit status
        exploit_status = []
        if vuln.get('ExploitAvailable'):
            exploit_status.append("âš ï¸ EXPLOIT AVAILABLE")
        if "ZERODAY" in vuln.get('VulnId', ''):
            exploit_status.append("ðŸš¨ ZERO-DAY")
        
        # Patch status
        patch_info = "âœ… Patch Available" if vuln.get('PatchAvailable') else "âŒ No Patch Available"
        
        # Build vulnerability block
        report_lines.extend([
            f"{severity_icon} [{idx}] {vuln.get('VulnId', 'N/A')} - CVSS {vuln.get('CVSS', 0)}",
            f"    {vuln.get('VulnTitle', 'No title available')}",
            "",
            f"    Severity: {vuln.get('Severity', 'Unknown')} | {patch_info}",
        ])
        
        if exploit_status:
            report_lines.append(f"    Status: {' | '.join(exploit_status)}")
        
        # Add remediation guidance
        vuln_id = vuln.get('VulnId', '')
        if vuln_id == "CVE-2024-49112":
            report_lines.extend([
                "",
                "    ðŸ”§ REMEDIATION:",
                "    â€¢ Apply Windows security updates immediately",
                "    â€¢ Disable SMBv1 protocol if enabled",
                "    â€¢ Restrict SMB access to trusted networks only",
                "    â€¢ Monitor for suspicious network activity on ports 445/139"
            ])
        elif vuln_id == "CVE-2024-49113":
            report_lines.extend([
                "",
                "    ðŸ”§ REMEDIATION:",
                "    â€¢ Install latest Windows Kerberos security patches",
                "    â€¢ Review domain controller configurations",
                "    â€¢ Enable Kerberos armoring (FAST) where supported",
                "    â€¢ Monitor for unusual authentication patterns"
            ])
        elif vuln_id == "CVE-2024-48951":
            report_lines.extend([
                "",
                "    ðŸ”§ REMEDIATION:",
                "    â€¢ Apply Windows graphics component updates",
                "    â€¢ Restrict access to graphics rendering services",
                "    â€¢ Monitor for suspicious graphics-related processes",
                "    â€¢ Update all graphics drivers to latest versions"
            ])
        elif vuln_id == "CVE-2024-48967":
            report_lines.extend([
                "",
                "    ðŸ”§ REMEDIATION:",
                "    â€¢ Apply NTLM security patches from Microsoft",
                "    â€¢ Migrate to Kerberos authentication where possible",
                "    â€¢ Enable NTLM auditing and restrict NTLM usage",
                "    â€¢ Review Group Policy settings for NTLM restrictions"
            ])
        elif "ZERODAY" in vuln_id:
            report_lines.extend([
                "",
                "    ðŸ”§ REMEDIATION:",
                "    â€¢ âš ï¸ NO OFFICIAL PATCH AVAILABLE (ZERO-DAY)",
                "    â€¢ Implement compensating controls immediately:",
                "      - Enable Windows Defender Exploit Guard",
                "      - Restrict kernel-mode driver installations",
                "      - Monitor for privilege escalation attempts",
                "      - Isolate system until patch is released",
                "    â€¢ Contact Microsoft Security Response Center (MSRC)"
            ])
        
        report_lines.extend([
            "",
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”",
            ""
        ])
    
    # Summary and recommendations
    critical_count = sum(1 for v in bobvm_vulns if v.get('Severity') == 'Critical')
    exploitable_count = sum(1 for v in bobvm_vulns if v.get('ExploitAvailable'))
    no_patch_count = sum(1 for v in bobvm_vulns if not v.get('PatchAvailable'))
    
    report_lines.extend([
        "ðŸ“‹ SUMMARY & RECOMMENDATIONS:",
        "",
        f"   â€¢ {critical_count} Critical vulnerabilities require immediate attention",
        f"   â€¢ {exploitable_count} vulnerabilities have public exploits available",
        f"   â€¢ {no_patch_count} vulnerabilities have no official patches yet",
        "",
        "   ðŸŽ¯ PRIORITY ACTIONS:",
        "   1. Isolate BobVM from production networks immediately",
        "   2. Apply all available security patches within 24 hours",
        "   3. Implement network segmentation and monitoring",
        "   4. Schedule emergency patching window for zero-day mitigation",
        "   5. Review and update incident response procedures",
        "",
        "   ðŸ”’ For zero-day vulnerabilities, engage security team for",
        "      compensating controls and advanced threat monitoring.",
        "",
        "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—",
        "â•‘  Report Generated by cveBuster Vulnerability Management Platform     â•‘",
        "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    ])
    
    formatted_report = "\n".join(report_lines)
    
    return formatted_report, 200, {'Content-Type': 'text/plain; charset=utf-8'}

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)
