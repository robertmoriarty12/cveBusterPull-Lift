"""
cveBuster Push Client - GUI Application
Generates fresh vulnerability data and pushes to Microsoft Sentinel via Azure Monitor Ingestion API
"""

import json
import random
import tkinter as tk
from tkinter import ttk, messagebox, scrolledtext
from datetime import datetime, timedelta
from azure.identity import ClientSecretCredential
from azure.monitor.ingestion import LogsIngestionClient
from azure.core.exceptions import HttpResponseError

# Real Windows CVEs for BobVM
BOBVM_CVES = [
    {
        "VulnId": "CVE-2024-49113",
        "VulnTitle": "Windows Kerberos Elevation of Privilege Vulnerability",
        "Severity": "Critical",
        "CVSS": 9.8,
        "AssetCriticality": "High",
        "PatchAvailable": False,
        "ExploitAvailable": True
    },
    {
        "VulnId": "CVE-2024-49112",
        "VulnTitle": "Windows Remote Code Execution in SMB Protocol",
        "Severity": "Critical",
        "CVSS": 10.0,
        "AssetCriticality": "High",
        "PatchAvailable": False,
        "ExploitAvailable": True
    },
    {
        "VulnId": "CVE-2024-48967",
        "VulnTitle": "Windows NTLM Security Feature Bypass Vulnerability",
        "Severity": "High",
        "CVSS": 8.8,
        "AssetCriticality": "High",
        "PatchAvailable": True,
        "ExploitAvailable": False
    },
    {
        "VulnId": "CVE-2024-48951",
        "VulnTitle": "Windows Graphics Component Remote Code Execution",
        "Severity": "Critical",
        "CVSS": 9.6,
        "AssetCriticality": "Medium",
        "PatchAvailable": True,
        "ExploitAvailable": True
    },
    {
        "VulnId": "CVE-2025-0001-ZERODAY",
        "VulnTitle": "Windows Kernel Privilege Escalation (Zero Day)",
        "Severity": "Critical",
        "CVSS": 9.9,
        "AssetCriticality": "High",
        "PatchAvailable": False,
        "ExploitAvailable": False
    }
]

def generate_bobvm_vulnerabilities(now):
    """Generate 5 specific real Windows CVEs for BobVM"""
    bobvm_vulns = []
    for cve_data in BOBVM_CVES:
        seconds_ago = random.randint(0, 300)
        last_seen = now - timedelta(seconds=seconds_ago)
        days_before_last_seen = random.randint(1, 30)
        first_seen = last_seen - timedelta(days=days_before_last_seen)

        vuln = {
            "VulnId": cve_data["VulnId"],
            "VulnTitle": cve_data["VulnTitle"],
            "Severity": cve_data["Severity"],
            "CVSS": cve_data["CVSS"],
            "MachineName": "BobVM",
            "AssetCriticality": cve_data["AssetCriticality"],
            "PatchAvailable": cve_data["PatchAvailable"],
            "ExploitAvailable": cve_data["ExploitAvailable"],
            "ExploitedInWild": cve_data["ExploitAvailable"] and random.choice([True, False]),
            "FirstSeen": first_seen.strftime("%Y-%m-%dT%H:%M:%SZ"),
            "LastSeen": last_seen.strftime("%Y-%m-%dT%H:%M:%SZ"),
            "LastScanTime": now.strftime("%Y-%m-%dT%H:%M:%SZ"),
            "Source": "cveBuster"
        }
        bobvm_vulns.append(vuln)
    return bobvm_vulns

def generate_vulnerability_data(num_records=500):
    """Generate mock vulnerability data with all records within last 5 minutes"""
    vulnerabilities = []
    severity_levels = ["Critical", "High", "Medium", "Low"]
    machine_names = [f"SRV-{random.choice(['WEB', 'APP', 'DB', 'DC'])}-{i:03d}"
                     for i in range(1, 51)]
    
    now = datetime.utcnow()
    vulnerabilities.extend(generate_bobvm_vulnerabilities(now))

    for i in range(1, num_records + 1):
        seconds_ago = random.randint(0, 300)
        last_seen = now - timedelta(seconds=seconds_ago)
        days_before_last_seen = random.randint(1, 30)
        first_seen = last_seen - timedelta(days=days_before_last_seen)

        severity = random.choice(severity_levels)
        cvss = round(random.uniform(4.0, 10.0), 1)
        exploit_available = random.choice([True, False])

        vuln = {
            "VulnId": f"CVE-2024-{10000 + i}",
            "VulnTitle": f"Security Vulnerability {i}",
            "Severity": severity,
            "CVSS": cvss,
            "MachineName": random.choice(machine_names),
            "AssetCriticality": random.choice(["High", "Medium", "Low"]),
            "PatchAvailable": random.choice([True, False]),
            "ExploitAvailable": exploit_available,
            "ExploitedInWild": exploit_available and random.choice([True, False]),
            "FirstSeen": first_seen.strftime("%Y-%m-%dT%H:%M:%SZ"),
            "LastSeen": last_seen.strftime("%Y-%m-%dT%H:%M:%SZ"),
            "LastScanTime": now.strftime("%Y-%m-%dT%H:%M:%SZ"),
            "Source": "cveBuster"
        }
        vulnerabilities.append(vuln)

    return vulnerabilities

class PushClientGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("cveBuster Push Client")
        self.root.geometry("800x700")
        
        # Create notebook for tabs
        notebook = ttk.Notebook(root)
        notebook.pack(fill='both', expand=True, padx=10, pady=10)
        
        # Tab 1: Push Data
        push_tab = ttk.Frame(notebook, padding="10")
        notebook.add(push_tab, text="Push Data")
        
        # Tab 2: Configuration (placeholder)
        config_tab = ttk.Frame(notebook, padding="10")
        notebook.add(config_tab, text="Configuration")
        ttk.Label(config_tab, text="Advanced configuration settings coming soon...", 
                 font=('Arial', 10)).pack(pady=20)
        
        # Tab 3: Analytics (placeholder)
        analytics_tab = ttk.Frame(notebook, padding="10")
        notebook.add(analytics_tab, text="Analytics")
        ttk.Label(analytics_tab, text="Vulnerability analytics dashboard coming soon...", 
                 font=('Arial', 10)).pack(pady=20)
        
        # Create main frame in push tab
        main_frame = ttk.Frame(push_tab, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Title
        title = ttk.Label(main_frame, text="cveBuster Vulnerability Scanner - Push Client", 
                         font=('Arial', 14, 'bold'))
        title.grid(row=0, column=0, columnspan=2, pady=10)
        
        # Configuration fields
        row = 1
        
        # Tenant ID
        ttk.Label(main_frame, text="Tenant ID (Directory ID):").grid(row=row, column=0, sticky=tk.W, pady=5)
        self.tenant_id = ttk.Entry(main_frame, width=50)
        self.tenant_id.grid(row=row, column=1, pady=5)
        row += 1
        
        # Application ID
        ttk.Label(main_frame, text="Application (Client) ID:").grid(row=row, column=0, sticky=tk.W, pady=5)
        self.client_id = ttk.Entry(main_frame, width=50)
        self.client_id.grid(row=row, column=1, pady=5)
        row += 1
        
        # Application Secret
        ttk.Label(main_frame, text="Application Secret:").grid(row=row, column=0, sticky=tk.W, pady=5)
        self.client_secret = ttk.Entry(main_frame, width=50, show="*")
        self.client_secret.grid(row=row, column=1, pady=5)
        row += 1
        
        # Data Collection Endpoint
        ttk.Label(main_frame, text="Data Collection Endpoint:").grid(row=row, column=0, sticky=tk.W, pady=5)
        self.dce_endpoint = ttk.Entry(main_frame, width=50)
        self.dce_endpoint.grid(row=row, column=1, pady=5)
        row += 1
        
        # DCR Immutable ID
        ttk.Label(main_frame, text="Data Collection Rule Immutable ID:").grid(row=row, column=0, sticky=tk.W, pady=5)
        self.dcr_id = ttk.Entry(main_frame, width=50)
        self.dcr_id.grid(row=row, column=1, pady=5)
        row += 1
        
        # Stream Name
        ttk.Label(main_frame, text="Stream Name:").grid(row=row, column=0, sticky=tk.W, pady=5)
        self.stream_name = ttk.Entry(main_frame, width=50)
        self.stream_name.insert(0, "Custom-cveBusterVulnerabilities")
        self.stream_name.grid(row=row, column=1, pady=5)
        row += 1
        
        # Send button
        self.send_button = ttk.Button(main_frame, text="Generate & Send Data", 
                                     command=self.send_data, style='Accent.TButton')
        self.send_button.grid(row=row, column=0, columnspan=2, pady=20)
        row += 1
        
        # Status/Log area
        ttk.Label(main_frame, text="Status Log:").grid(row=row, column=0, sticky=tk.W, pady=5)
        row += 1
        
        self.log_area = scrolledtext.ScrolledText(main_frame, width=80, height=15, state='disabled')
        self.log_area.grid(row=row, column=0, columnspan=2, pady=5)
        
    def log(self, message):
        """Add message to log area"""
        self.log_area.config(state='normal')
        timestamp = datetime.now().strftime("%H:%M:%S")
        self.log_area.insert(tk.END, f"[{timestamp}] {message}\n")
        self.log_area.see(tk.END)
        self.log_area.config(state='disabled')
        self.root.update()
    
    def validate_inputs(self):
        """Validate all required fields are filled"""
        if not self.tenant_id.get().strip():
            messagebox.showerror("Validation Error", "Tenant ID is required")
            return False
        if not self.client_id.get().strip():
            messagebox.showerror("Validation Error", "Application (Client) ID is required")
            return False
        if not self.client_secret.get().strip():
            messagebox.showerror("Validation Error", "Application Secret is required")
            return False
        if not self.dce_endpoint.get().strip():
            messagebox.showerror("Validation Error", "Data Collection Endpoint is required")
            return False
        if not self.dcr_id.get().strip():
            messagebox.showerror("Validation Error", "Data Collection Rule Immutable ID is required")
            return False
        if not self.stream_name.get().strip():
            messagebox.showerror("Validation Error", "Stream Name is required")
            return False
        
        return True
    
    def send_data(self):
        """Generate data and send to Sentinel"""
        if not self.validate_inputs():
            return
        
        self.send_button.config(state='disabled')
        self.log("=" * 60)
        self.log("Starting data generation and push to Sentinel...")
        
        try:
            # Step 1: Generate data (always 500 + 5 BobVM CVEs)
            num_records = 500
            self.log(f"Generating {num_records} vulnerability records + 5 BobVM CVEs...")
            data = generate_vulnerability_data(num_records)
            self.log(f"✓ Generated {len(data)} total records")
            
            # Count BobVM records
            bobvm_count = sum(1 for v in data if v['MachineName'] == 'BobVM')
            self.log(f"  - {bobvm_count} BobVM-specific Windows CVEs")
            self.log(f"  - {len(data) - bobvm_count} general vulnerability records")
            
            # Step 2: Authenticate with Azure
            self.log("\nAuthenticating with Azure...")
            credential = ClientSecretCredential(
                tenant_id=self.tenant_id.get().strip(),
                client_id=self.client_id.get().strip(),
                client_secret=self.client_secret.get().strip()
            )
            self.log("✓ Authentication successful")
            
            # Step 3: Create ingestion client
            self.log("\nConnecting to Data Collection Endpoint...")
            client = LogsIngestionClient(
                endpoint=self.dce_endpoint.get().strip(),
                credential=credential,
                logging_enable=True
            )
            self.log("✓ Connected to DCE")
            
            # Step 4: Send data to Sentinel
            self.log(f"\nUploading {len(data)} records to Sentinel...")
            self.log(f"  DCR ID: {self.dcr_id.get().strip()}")
            self.log(f"  Stream: {self.stream_name.get()}")
            
            response = client.upload(
                rule_id=self.dcr_id.get().strip(),
                stream_name=self.stream_name.get(),
                logs=data
            )
            
            self.log("\n✓ SUCCESS! Data uploaded to Microsoft Sentinel")
            self.log(f"  Response: {response if response else 'HTTP 204 No Content (success)'}")
            self.log(f"  Total records sent: {len(data)}")
            self.log(f"  Timestamp: {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')} UTC")
            self.log("  Data should appear in Log Analytics within 5-10 minutes")
            
            messagebox.showinfo("Success", 
                              f"Successfully sent {len(data)} vulnerability records to Sentinel!\n\n"
                              f"Check Log Analytics in 5-10 minutes:\n"
                              f"cveBusterVulnerabilities_CL | take 10")
            
        except HttpResponseError as e:
            error_msg = f"Azure API Error: {str(e)}"
            self.log(f"\n✗ ERROR: {error_msg}")
            messagebox.showerror("Upload Failed", error_msg)
        except Exception as e:
            error_msg = f"Error: {str(e)}"
            self.log(f"\n✗ ERROR: {error_msg}")
            messagebox.showerror("Error", error_msg)
        finally:
            self.send_button.config(state='normal')

def main():
    root = tk.Tk()
    app = PushClientGUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()
